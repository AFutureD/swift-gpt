/// Represents an error that occurred during generation.
public struct GenerationError: Codable, Sendable {
    /// The error code.
    public let code: String?
    /// A descriptive message for the error.
    public let message: String?
}

/// Represents the reason for stopping generation.
public struct GenerationStop: Codable, Sendable {
    /// The stop reason code.
    public let code: String?
    /// A descriptive message for the stop reason.
    public let message: String?
}

// MARK: TokenUsage

/// Represents the token usage for a generation request.
public struct TokenUsage: Codable, Sendable {
    /// The number of tokens in the input prompt.
    public let input: Int?
    /// The number of tokens in the generated output.
    public let output: Int?
    /// The total number of tokens used.
    public let total: Int?
}

// MARK: ModelResponse

/// Represents a complete, non-streaming response from an LLM.
public struct ModelResponse: Codable, Sendable {
    /// A unique identifier for the response.
    public let id: String?
    
    /// The name of the model that generated the response.
    public let model: String?
    
    /// The items that generated by the model.
    public let items: [GeneratedItem]

    /// The token usage for the request.
    public let usage: TokenUsage?

    /// The reason for stopping generation, if applicable.
    public let stop: GenerationStop?

    /// Any error that occurred during generation.
    public let error: GenerationError?

    public init(id: String?, model: String?, items: [GeneratedItem], usage: TokenUsage?, stop: GenerationStop?, error: GenerationError?) {
        self.id = id
        self.model = model
        self.items = items
        self.usage = usage
        self.stop = stop
        self.error = error
    }
}

// MARK: ModelStreamResponse

/// An enumeration of events that can occur during a streaming response.
public enum ModelStreamResponse: Sendable {
    // Response
    /// The response stream has been created.
    case create(Event<ModelResponse?>)
    /// The response stream has completed.
    case completed(Event<ModelResponse>)

    // Item
    /// A new response item has been added.
    case itemAdded(Event<GeneratedItem>)
    /// A response item is complete.
    case itemDone(Event<GeneratedItem>)

    // Item.Content
    /// New content has been added to an item.
    case contentAdded(Event<MessageContent>)
    /// A partial update (delta) for a content block has been received.
    case contentDelta(Event<MessageContent>) // any PartialUpdatable & GeneratedItem
    /// A content block is complete.
    case contentDone(Event<MessageContent>)
}

// MARK: ModelStreamResponse + Event

extension ModelStreamResponse {
    /// A container for a streaming event, including the event name and its associated data.
    public struct Event<T>: Codable, Sendable where T: Codable & Sendable {
        /// The name of the event.
        public let event: EventName
        /// The data associated with the event.
        public let data: T

        public init(event: EventName, data: T) {
            self.event = event
            self.data = data
        }
    }
}

extension ModelStreamResponse.Event: CustomStringConvertible {
    public var description: String {
        "Event('\(event.rawValue)'): \(data)"
    }
}

// MARK: ModelStreamResponse + EventName

extension ModelStreamResponse {
    /// A type that represents the name of a streaming event.
    public struct EventName: RawRepresentable, Hashable, Codable, Sendable {
        public let rawValue: String
        
        public init(rawValue: String) {
            self.rawValue = rawValue
        }
    }
}

extension ModelStreamResponse.EventName {
    /// The event name for when a response stream is created.
    public static let create = Self(rawValue: "response.create")
    /// The event name for when a response stream is completed.
    public static let completed = Self(rawValue: "response.completed")
    /// The event name for when a new item is added to the response.
    public static let itemAdded = Self(rawValue: "response.item.added")
    /// The event name for when an item in the response is complete.
    public static let itemDone = Self(rawValue: "response.item.done")
    /// The event name for when new content is added to an item.
    public static let contentAdded = Self(rawValue: "response.item.content.added")
    /// The event name for when a partial update (delta) for content is received.
    public static let contentDelta = Self(rawValue: "response.item.content.delta")
    /// The event name for when a content block is complete.
    public static let contentDone = Self(rawValue: "response.item.content.done")
}

// MARK: ModelStreamResponse + Codable

extension ModelStreamResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case event
        case data
    }
    
    public init(from decoder: any Decoder) throws {
        let conatiner = try decoder.container(keyedBy: CodingKeys.self)
        let event = try conatiner.decode(EventName.self, forKey: .event)
        
        switch event {
        case .create:
            self = try .create(.init(from: decoder))
        case .completed:
            self = try .completed(.init(from: decoder))
        case .itemAdded:
            self = try .itemAdded(.init(from: decoder))
        case .itemDone:
            self = try .itemDone(.init(from: decoder))
        case .contentAdded:
            self = try .contentAdded(.init(from: decoder))
        case .contentDelta:
            self = try .contentDelta(.init(from: decoder))
        case .contentDone:
            self = try .contentDone(.init(from: decoder))
        default:
            throw DecodingError.typeMismatch(EventName.self, .init(codingPath: [], debugDescription: "Unknown EventName when decode ModelStreamResponse"))
        }
    }
    
    public func encode(to encoder: any Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .create(let event):
            try container.encode(event)
        case .completed(let event):
            try container.encode(event)
        case .itemAdded(let event):
            try container.encode(event)
        case .itemDone(let event):
            try container.encode(event)
        case .contentAdded(let event):
            try container.encode(event)
        case .contentDelta(let event):
            try container.encode(event)
        case .contentDone(let event):
            try container.encode(event)
        }
    }
}
